<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hand Tracking</title>
    <style>
        /* ... (keep existing styles the same) ... */
    </style>
</head>
<body>
    <div id="status">ðŸŸ  Starting camera...</div>
    <div id="videoContainer">
        <video id="videoElement" autoplay playsinline muted></video>
        <div id="trackBox" class="track-box"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        const statusElement = document.getElementById('status');
        const videoElement = document.getElementById('videoElement');
        const trackBox = document.getElementById('trackBox');
        let camera = null;

        // 1. Enhanced MediaPipe Hands Configuration
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            selfieMode: true,
            maxNumHands: 1,
            modelComplexity: 0,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        // 2. Camera Initialization with Fallbacks
        async function initializeCamera() {
            try {
                // Try environment camera first
                camera = new Camera(videoElement, {
                    onFrame: async () => {
                        try {
                            await hands.send({ image: videoElement });
                        } catch (error) {
                            statusElement.textContent = "ðŸ”´ Frame processing error";
                        }
                    },
                    width: 640,
                    height: 480,
                    facingMode: 'environment'
                });

                await camera.start();
                statusElement.textContent = "ðŸŸ¢ Camera ready! Show your hand";
                
                // Add resize handler for proper coordinate mapping
                window.addEventListener('resize', updateCoordinateSystem);
                updateCoordinateSystem();

            } catch (environmentError) {
                console.log('Environment camera failed, trying user-facing');
                try {
                    // Fallback to user-facing camera
                    camera = new Camera(videoElement, {
                        onFrame: async () => {
                            await hands.send({ image: videoElement });
                        },
                        width: 640,
                        height: 480,
                        facingMode: 'user'
                    });
                    await camera.start();
                    statusElement.textContent = "ðŸŸ¢ Camera ready! Show your hand";
                } catch (userError) {
                    statusElement.textContent = "ðŸ”´ Camera access denied";
                    console.error('Camera initialization failed:', userError);
                }
            }
        }

        // 3. Coordinate System Management
        let videoRect = null;
        function updateCoordinateSystem() {
            videoRect = videoElement.getBoundingClientRect();
        }

        function toScreenCoordinates(x, y) {
            return {
                x: x * videoRect.width + videoRect.left,
                y: y * videoRect.height + videoRect.top
            };
        }

        // 4. Optimized Hand Tracking Processing
        hands.onResults((results) => {
            if (!results.multiHandLandmarks) {
                trackBox.style.display = 'none';
                return;
            }

            const landmarks = results.multiHandLandmarks[0];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];

            const indexPos = toScreenCoordinates(indexTip.x, indexTip.y);
            const middlePos = toScreenCoordinates(middleTip.x, middleTip.y);

            const boxWidth = Math.abs(indexPos.x - middlePos.x) + 40;
            const boxHeight = Math.abs(indexPos.y - middlePos.y) + 40;
            const centerX = (indexPos.x + middlePos.x) / 2;
            const centerY = (indexPos.y + middlePos.y) / 2;

            trackBox.style.display = 'block';
            trackBox.style.left = `${centerX}px`;
            trackBox.style.top = `${centerY}px`;
            trackBox.style.width = `${boxWidth}px`;
            trackBox.style.height = `${boxHeight}px`;
        });

        // 5. Camera Cleanup and Error Handling
        function stopCamera() {
            if (camera) {
                camera.stop();
                camera = null;
            }
            if (videoElement.srcObject) {
                videoElement.srcObject.getTracks().forEach(track => track.stop());
            }
        }

        // Initialize when ready
        (async function() {
            try {
                await hands.initialize();
                await initializeCamera();
            } catch (error) {
                statusElement.textContent = `ðŸ”´ Initialization failed: ${error.message}`;
                console.error('Initialization error:', error);
            }
        })();

        // Cleanup on exit
        window.addEventListener('beforeunload', stopCamera);
        window.addEventListener('pagehide', stopCamera);
    </script>
</body>
</html>
